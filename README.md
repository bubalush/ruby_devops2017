# ruby_devops2017
# TASK 1
## Task1_1: Обработка строк
###### Description:
На вход подается переменная строки.

Написать однострочную инструкцию, которая поменяет порядок букв на противоположный и понизит все буквы в регистре кроме первой.

Вернуть значение результата. Оригинальный объект, на который ссылается переменная, должен быть изменен.
###### Пример:
```ruby
a = "dniMyMdegnahCybuR"
a.object_id # => 12345
```
Важно! Сигнатура метода (имя, количество аргументов) должно совпадать с примером
```ruby
def test(value)
 < ваш код тут >
end
```
```ruby
test(a) # => "Rubychangedmymind"
test(a).class # => String
test(a).object_id # => 12345
puts a # => "Rubychangedmymind"
```
###### Решение:

[task1_1.rb](scripts/task1_1.rb)

## Task1_2: Фильтрация чисел
###### Description:

Вернуть массив чисел от 10 до 3 не влючая 5, причём числа, кратные 3м, вывести в квадрате.

###### Пример:
```ruby
# Важно! Сигнатура метода (имя, количество аргументов) должно совпадать с примером
def test
 < ваш код тут >
end
test # => [10, 81, 8, 7, 36, 4, 9]
```
###### Решение:

[task1_2.rb](scripts/task1_2.rb)

## Task1_3: Перестановка цифр
###### Description:

Дано число. Вернуть число, где первая цифра стала последней, вторая - предпоследней и тд.

Ноль остается нулем.

Знак минуса также сохраняется.

###### Примеры:
```ruby
number = 123
# Важно! Сигнатура метода (имя, количество аргументов) должно совпадать с примером
def test(value)
 < ваш код тут >
end
test(number) # => 321
test(number).class # => Integer
test(-461) # => -164
test(-1) < 0 # => true
```
###### Решение:
[task1_3.rb](scripts/task1_3.rb)

## Task3: Модуль-парсер
###### Description:

Реализовать Ruby модуль для парсинга определенных данных следующей архитектуры:

###### Условия:

    Все должно быть заскоуплено в модуле Parser
    Внутри модуля должен быть класс Base с общим фунционалом для всех кастомных парсеров
    В Base должна быть константа TIMEOUT_LIMIT со значеним по-умолчанию 1 секунда. Данная константа может быть переопределена в каждом кастомном классе
    Каждый кастомный парсер должен наследоваться от Base
    Во всех классах публичными должны быть только перечисленные методы, вся остальная реализация должна быть сокрыта.
    Список доступных публичных методов (за исключением стандартных):
        parse
        report
        search_key
        search_key=(...)

    Обзор парсеров:
        class Base: базовый парсер, принимает на вход текст и подстроку, его report вовзращает количество найденых совпадений, а search_key позволяет изменить подстроку для поиска. Пример работы:
```ruby
      base = Parser::Base.new("hello world\nOko", 'o')
      puts base.parse.report # => 3
      base.search_key = 'world'
      base.parse
      puts base.report # => 1
```
        class Link: парсер который достает все ссылки из переданного текста, принимает только текст. Пример работы:
```ruby
      link = Parser::Link.new("<div><a href='x.com'>x</a></div>\n<a href='y.com'>y</a>")
      link.parse
      p link.report # => ["x.com", "y.com"]
```
        class Custom: парсер который реализует построчный поиск переданного текста произвольным образом, принимает только текст. Пример работы:
```ruby
      custom = Parser::Custom.new("hello <a href='tut.by'>tost</a> world\nhello <a href='tut.by'>tost2</a> world")
      custom.parse do |line|
        line.match(/(tost\w*)</)[1]
      end.report # => ["tost", "tost2"]
```
В случае возникновения ошибки при парсинге, метод parse не должен падать, а метод report в таком случае возвращает соответствующее классу нулевое значение: 0 - для Base, [] - для всех остальных.
```ruby
    custom = Parser::Custom.new("abs")
    custom.parse { |line| line.match(/(\d+)/)[1] }
    p custom.report # => []
```
###### Решение:
[task3.rb](scripts/task3.rb)