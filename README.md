# ruby_devops2017
# TASK 1
## Task1_1: Обработка строк
###### Description:
На вход подается переменная строки.

Написать однострочную инструкцию, которая поменяет порядок букв на противоположный и понизит все буквы в регистре кроме первой.

Вернуть значение результата. Оригинальный объект, на который ссылается переменная, должен быть изменен.
###### Пример:
```ruby
a = "dniMyMdegnahCybuR"
a.object_id # => 12345
```
Важно! Сигнатура метода (имя, количество аргументов) должно совпадать с примером
```ruby
def test(value)
 < ваш код тут >
end
```
```ruby
test(a) # => "Rubychangedmymind"
test(a).class # => String
test(a).object_id # => 12345
puts a # => "Rubychangedmymind"
```
###### Решение:

[task1_1.rb](scripts/task1_1.rb)

## Task1_2: Фильтрация чисел
###### Description:

Вернуть массив чисел от 10 до 3 не влючая 5, причём числа, кратные 3м, вывести в квадрате.

###### Пример:
```ruby
# Важно! Сигнатура метода (имя, количество аргументов) должно совпадать с примером
def test
 < ваш код тут >
end
test # => [10, 81, 8, 7, 36, 4, 9]
```
###### Решение:

[task1_2.rb](scripts/task1_2.rb)

## Task1_3: Перестановка цифр
###### Description:

Дано число. Вернуть число, где первая цифра стала последней, вторая - предпоследней и тд.

Ноль остается нулем.

Знак минуса также сохраняется.

###### Примеры:
```ruby
number = 123
# Важно! Сигнатура метода (имя, количество аргументов) должно совпадать с примером
def test(value)
 < ваш код тут >
end
test(number) # => 321
test(number).class # => Integer
test(-461) # => -164
test(-1) < 0 # => true
```
###### Решение:
[task1_3.rb](scripts/task1_3.rb)

## Task3: Модуль-парсер
###### Description:

Реализовать Ruby модуль для парсинга определенных данных следующей архитектуры:

###### Условия:

    Все должно быть заскоуплено в модуле Parser
    Внутри модуля должен быть класс Base с общим фунционалом для всех кастомных парсеров
    В Base должна быть константа TIMEOUT_LIMIT со значеним по-умолчанию 1 секунда. Данная константа может быть переопределена в каждом кастомном классе
    Каждый кастомный парсер должен наследоваться от Base
    Во всех классах публичными должны быть только перечисленные методы, вся остальная реализация должна быть сокрыта.
    Список доступных публичных методов (за исключением стандартных):
        parse
        report
        search_key
        search_key=(...)

    Обзор парсеров:
        class Base: базовый парсер, принимает на вход текст и подстроку, его report вовзращает количество найденых совпадений, а search_key позволяет изменить подстроку для поиска. Пример работы:
```ruby
      base = Parser::Base.new("hello world\nOko", 'o')
      puts base.parse.report # => 3
      base.search_key = 'world'
      base.parse
      puts base.report # => 1
```
        class Link: парсер который достает все ссылки из переданного текста, принимает только текст. Пример работы:
```ruby
      link = Parser::Link.new("<div><a href='x.com'>x</a></div>\n<a href='y.com'>y</a>")
      link.parse
      p link.report # => ["x.com", "y.com"]
```
        class Custom: парсер который реализует построчный поиск переданного текста произвольным образом, принимает только текст. Пример работы:
```ruby
      custom = Parser::Custom.new("hello <a href='tut.by'>tost</a> world\nhello <a href='tut.by'>tost2</a> world")
      custom.parse do |line|
        line.match(/(tost\w*)</)[1]
      end.report # => ["tost", "tost2"]
```
В случае возникновения ошибки при парсинге, метод parse не должен падать, а метод report в таком случае возвращает соответствующее классу нулевое значение: 0 - для Base, [] - для всех остальных.
```ruby
    custom = Parser::Custom.new("abs")
    custom.parse { |line| line.match(/(\d+)/)[1] }
    p custom.report # => []
```
###### Решение:
[task3.rb](scripts/task3.rb)

## Task4: Healthcheck Monitoring
###### Description:
Вам необходимо реализовать в модуле Mtn класс Healthcheck, который будет проверять сервера на доступность.

Сервера уже реализованы, вам достаточно знать, что это некий объект, у которого есть метод #status, работающий следующим образом: - возвращает true, если сервер доступен и отвечает - возвращает ошибку Mtn::Status400 или Mtn::Status500, если сервер доступен, но приболел - возвращает ошибку Mtn::TimeoutError, если сервер недоступен в принципе

Все ошибки отнаследованы от StandardError.

Каждый сервис вашего Healthcheck должен принимать сервер при инициализации и иметь как минимум метод #check!, который будет проверять статус сервера. При этом:

    сервис ведет подсчет количества проверок каждого сервиса и их положительных\отрицательных статусов (смотри пример ниже)
    в случае, когда сервер доступен, возвращает строку вида: "OK (количество_положительных_ответов/общее_количество_проверок_этого_сервера")
    в случае, когда сервер недоступен, возвращает строку вида:
    "КЛАСС_ПОСЛЕДНЕЙ_ОШИБКИ_КАПСЛОКОМ (количество_положительных_ответов/общее_количество_проверок_этого_сервера)"
    если же сломался сам сервис, возвращает просто строку:
    "FAIL"

Пример проверки вашего сервиса на 3х серверах:
```ruby
# server1-3 приходят извне
mtn1 = Mtn::Healthcheck.new(server1)
mtn2 = Mtn::Healthcheck.new(server2)
mtn3 = Mtn::Healthcheck.new(server3)
mtn4 = Mtn::Healthcheck.new('xx не сервер или ошибка случилась внутри самого сервиса xx')
mtn1.check! # => "OK (1/1)"
mtn2.check! # => "MTN::TIMEOUTERROR (0/1)"
mtn3.check! # => "MTN::STATUS500 (0/1)"
mtn4.check! # => "FAIL"
mtn1.check! # => "OK (2/2)"
mtn2.check! # => "MTN::TIMEOUTERROR (0/2)"
mtn3.check! # => "MTN::STATUS400 (0/2)"
mtn4.check! # => "FAIL"

# и так далее, как видно, сервер может поменять свой статус или ошибку
```
Ничего выводить на экран не нужно, это просто строка как значение!

###### Решение:
[task4.rb](scripts/task4.rb) - окончательное решение

[task4_v2.rb](scripts/task4_v2.rb) - решение с реализацией проверочного класса